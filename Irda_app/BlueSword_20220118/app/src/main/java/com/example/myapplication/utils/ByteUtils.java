package com.example.myapplication.utils;import android.widget.Toast;import com.example.myapplication.entity.Card;import com.example.myapplication.entity.Way;import org.apache.commons.lang3.StringUtils;import java.io.IOException;import java.io.InputStream;import java.math.BigInteger;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.List;import java.util.Locale;import java.util.Timer;import java.util.TimerTask;import java.util.regex.Matcher;import java.util.regex.Pattern;import tw.com.prolific.driver.pl2303.PL2303Driver;/** * Byte转换工具 * * @author 钟三 */public class ByteUtils {    PL2303Driver mSerial;    /**     * 十六进制字符串转byte[]     *     * @param hex 十六进制字符串     * @return byte[]     */    public static byte[] hexStr2Byte(String hex) {        if (hex == null) {            return new byte[]{};        }        // 奇数位补0        if (hex.length() % 2 != 0) {            hex = "0" + hex;        }        int length = hex.length();        ByteBuffer buffer = ByteBuffer.allocate(length / 2);        for (int i = 0; i < length; i++) {            String hexStr = hex.charAt(i) + "";            i++;            hexStr += hex.charAt(i);            byte b = (byte) Integer.parseInt(hexStr, 16);            buffer.put(b);        }        return buffer.array();    }    /**     * byte[]数组转十六进制字符串     *     * @param array byte[]     * @return 十六进制字符串     */    public static String byteArrayToHexString(byte[] array) {        if (array == null) {            return "";        }        StringBuffer buffer = new StringBuffer();        for (int i = 0; i < array.length; i++) {            buffer.append(byteToHex(array[i]));        }        return buffer.toString();    }    /**     * byte字符转十六进制字符     *     * @param b byte     * @return 十六进制字符     */    public static String byteToHex(byte b) {        String hex = Integer.toHexString(b & 0xFF);        if (hex.length() == 1) {            hex = '0' + hex;        }        return hex.toUpperCase(Locale.getDefault());    }    public static String toHex(int num) {        char[] chs = new char[8];//定义一个数组储存转换好的        // 16进制码        int index = chs.length - 1;//定义索引数值        while (num != 0) {            int temp = num & 15;            if (temp > 9)                chs[--index] = ((char) (temp - 10 + 'A'));            else                chs[--index] = ((char) (temp + '0'));            num = num >>> 4;        }        System.out.println("SHUSHU===="+toString(chs, index).length());        if (toString(chs, index).length() < 3) {            return ("0" + toString(chs, index)).trim();        } else {            return toString(chs, index).trim();        }    }    //定义一个函数将字符数组转成字符串。    public static String toString(char[] arr, int index) {        String temp = "";        for (int x = index; x < arr.length; x++) {            temp = temp + arr[x];        }        return temp;    };//字节转16进制  高位在前低位在后    public static int bytes4ToInt(byte[] src) {        int value = (int) (                ((src[0] & 0xFF)<<24)|                        ((src[1] & 0xFF)<<16)|                        ((src[2] & 0xFF)<< 8)|                        (src[3] & 0xFF));        return value;    }    public static String byteArrayToHexStr(byte[] bytes) {        String strHex;        StringBuilder sb = new StringBuilder();        for (byte aByte : bytes) {            strHex = Integer.toHexString(aByte & 0xFF);            sb.append((strHex.length() == 1) ? "0" : "").append(strHex); // 每个字节由两个字符表示，位数不够，高位补0        }        return sb.toString().trim();    }    public static byte[] StringtoBytes(String data){        if(data == null || data.equals("")){            return null;        }        data = data.toUpperCase();        char[] datachar = data.toCharArray();        byte[] getbytes = new byte[data.length()/ 2];        for( int i = 0; i <data.length()/2 ; i++){            int pos = i * 2;            getbytes[i] = (byte) (charToByte(datachar[pos]) << 4 | charToByte(datachar[pos + 1]));        }        return getbytes;    }    private static byte charToByte(char c) {        return (byte) "0123456789ABCDEF".indexOf(c);    }    public static String strToHexStr(String str) {        char[] chars = "0123456789ABCDEF".toCharArray();        StringBuilder sb = new StringBuilder("");        byte[] bs = str.getBytes();        int bit;        for (int i = 0; i < bs.length; i++) {            bit = (bs[i] & 0x0f0) >> 4;            sb.append(chars[bit]);            bit = bs[i] & 0x0f;            sb.append(chars[bit]);            // sb.append(' ');        }        return sb.toString().trim();    }    //生成16进制混合模式    public static String geCreateComType(StringBuilder sb, String comType) {        if (isNumeric(comType.trim())) {            sb.append(toHex(Integer.parseInt(comType)));        } else {            sb.append(strToHexStr(comType));        }        return sb.toString();    }    /**     * 利用正则表达式判断字符串是否是数字     *     * @param str     * @return     */    public static boolean isNumeric(String str) {        Pattern pattern = Pattern.compile("[0-9]*");        Matcher isNum = pattern.matcher(str);        if (!isNum.matches()) {            return false;        }        return true;    }    /**     * Hex转byte[]，两种情况，Hex长度为奇数最后一个字符会被舍去     */    public static byte[] hexTobytes(String hex) {        if (hex.length() < 1) {            return null;        } else {            byte[] result = new byte[hex.length() / 2];            int j = 0;            for (int i = 0; i < hex.length(); i += 2) {                result[j++] = (byte) Integer.parseInt(hex.substring(i, i + 2), 16);            }            return result;        }    }    public static byte[] hexToByte(String hex){        int m = 0, n = 0;        int byteLen = hex.length() / 2; // 每两个字符描述一个字节        byte[] ret = new byte[byteLen];        for (int i = 0; i < byteLen; i++) {            m = i * 2 + 1;            n = m + 1;            int intVal = Integer.decode("0x" + hex.substring(i * 2, m) + hex.substring(m, n));            ret[i] = Byte.valueOf((byte)intVal);        }        return ret;    }    /**     * Hex转byte[]，两种情况，Hex长度为奇数最后一个字符会被舍去     */    public static byte[] hexTTobytes(String hex) {        if (hex.length() < 1) {            return null;        } else {            byte[] result = new byte[hex.length()-1 / 2];            int j = 0;            for (int i = 0; i < hex.length()-1; i += 2) {                result[j++] = (byte) Integer.parseInt(hex.substring(i, i + 2), 16);            }            return result;        }    }    public static String stringToHexString(String s) {        String str = "";        for (int i = 0; i < s.length(); i++) {            int ch = s.charAt(i);            String s4 = Integer.toHexString(ch);            str = str + s4;        }        return str;    }    public static byte[] hexString2Intger(String str) {        byte[] byteTarget = new byte[str.length() / 4];        for (int i = 0; i < str.length() / 4; ++i)            byteTarget[i] = (byte)(Integer.parseInt(str.substring(i * 4, i * 4 +4), 16) & 0xff);        return byteTarget;    }    public static String byteArrayToHex(byte[] bytes) {        StringBuilder result = new StringBuilder();        for (int index = 0, len = bytes.length; index <= len - 1; index += 1) {            int char1 = ((bytes[index] >> 4) & 0xF);            char chara1 = Character.forDigit(char1, 16);            int char2 = ((bytes[index]) & 0xF);            char chara2 = Character.forDigit(char2, 16);            result.append(chara1);            result.append(chara2);        }        return result.toString();    }    /**     * 方法三：     * byte[] to hex string     *     * @param bytes     * @return     */    public static String bytesToHexFun3(byte[] bytes) {        StringBuilder buf = new StringBuilder(bytes.length * 2);        for(byte b : bytes) { // 使用String的format方法进行转换            buf.append(String.format("%02x", new Integer(b & 0xff)));        }        return buf.toString();    }    public static  String bytesToHexStrings(byte[] bArray) {        StringBuffer sb = new StringBuffer(bArray.length);        String sTemp;        for (int i = 0; i < bArray.length; i++) {            sTemp = Integer.toHexString(0xFF & bArray[i]);            if (sTemp.length() < 2)                sb.append(0);            sb.append(sTemp.toUpperCase());        }        return sb.toString();    }    public static String byteToHex(byte[] bytes){        String strHex = "";        StringBuilder sb = new StringBuilder("");        for (int n = 0; n < bytes.length; n++) {            strHex = Integer.toHexString(bytes[n] & 0xFF);            sb.append((strHex.length() == 1) ? "0" + strHex : strHex); // 每个字节由两个字符表示，位数不够，高位补0        }        return sb.toString().trim();    }    /**     * 十进制数据转换为16进制并高位在前，低位在后     * @param num 十进制数据     * @return     */    public static String numToHex(int num) {        String hex = "";        while(num != 0) {            String h = Integer.toString(num & 0xff, 16);            if((h.length() & 0x01) == 1)                h = '0' + h;            hex = hex + h;           num = num >> 8;        }        // 将每个字节取出来        return reverseHex(hex);    }    private static String reverseHex(final String hex) {        final char[] charArray = hex.toCharArray();        final int length = charArray.length;        final int times = length / 2;        for (int c1i = 0; c1i < times; c1i += 2) {            final int c2i = c1i + 1;            final char c1 = charArray[c1i];            final char c2 = charArray[c2i];            final int c3i = length - c1i - 2;            final int c4i = length - c1i - 1;            charArray[c1i] = charArray[c3i];            charArray[c2i] = charArray[c4i];            charArray[c3i] = c1;            charArray[c4i] = c2;        }        return new String(charArray);    }    /**     * 字符串补0     * @param str     * @param strLength     * @return     */    public static String addZeroForNum(String str, int strLength)    {        int strLen =str.length();        if(strLen<strLength){            while(strLen<strLength){                StringBuffer sb=new StringBuffer();                //sb.append("0").append(str);// 左补0                sb.append(str).append("0");//右补0                str = sb.toString();                strLen = str.length();            }        }        str = String.format(str).toUpperCase();//转为大写        return str;    }    /**     * 将字节转换为十六进制的字符串（）     *     * @param bytesCommand     * @return     * @from 忘了     */    public static String bytesToHexString(byte[] bytesCommand) {        StringBuilder stringBuilder = new StringBuilder("");        if (bytesCommand == null || bytesCommand.length <= 0) {            return null;        }        for (int i = 0; i < bytesCommand.length; i++) {            int v = bytesCommand[i] & 0xFF;            String hv = Integer.toHexString(v);            if (hv.length() < 2) {                stringBuilder.append(0);            }            stringBuilder.append(hv);        }        return stringBuilder.toString();    }    public static String str2HexStrR(String str)    {        char[] chars = "0123456789ABCDEF".toCharArray();        StringBuilder sb = new StringBuilder("");        byte[] bs = str.getBytes();        int bit;        for (int i = 0; i < bs.length; i++)        {            bit = (bs[i] & 0x0f0) >> 4;            sb.append(chars[bit]);            bit = bs[i] & 0x0f;            sb.append(chars[bit]);            sb.append(' ');        }        return sb.toString().trim();    }    public static String byte2HexStr(byte[] b)    {        String stmp="";        StringBuilder sb = new StringBuilder("");        for (int n=0;n<b.length;n++)        {            stmp = Integer.toHexString(b[n] & 0xFF);            sb.append((stmp.length()==1)? "0"+stmp : stmp);            sb.append(" ");        }        return sb.toString().toUpperCase().trim();    }    public  static byte[] hexToByteArray4(String hex)    {        int l = hex.length();        byte[] data = new byte[l / 2];        for (int i = 0; i < l; i += 2)        {            data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)                    + Character.digit(hex.charAt(i + 1), 16));        }        return data;    }    public static  String toHex(String arg) {        return String.format("%040x", new BigInteger(1, arg.getBytes(/*YOUR_CHARSET?*/)));    }    public static String str2HexStr(String str)    {        char[] chars = "0123456789ABCDEF".toCharArray();        StringBuilder sb = new StringBuilder("");        byte[] bs = str.getBytes();        int bit;        for (int i = 0; i < bs.length; i++)        {            bit = (bs[i] & 0x0f0) >> 4;            sb.append(chars[bit]);            bit = bs[i] & 0x0f;            sb.append(chars[bit]);           // sb.append(' ');        }        return sb.toString().trim();    }    /**     * 从串口读取数据,该方法读取后数据就没了     *     * @param     * @return 读取到的数据     */    public static byte[] readFromPort(PL2303Driver mSerial) {        byte[] bytes = {};        try {            //in = serialPort.getInputStream();            // 缓冲区大小为一个字节            byte[] readBuffer = new byte[1];            int bytesNum = mSerial.read(readBuffer);            while (bytesNum > 0) {                bytes = ArrayUtils.concat(bytes, readBuffer);                bytesNum = mSerial.read(readBuffer);            }        } catch (Exception e) {            e.printStackTrace();        } finally {        }        return bytes;    }    //获取get列表    public static String getUsbToStrings(String comType) {        int length = comType.length();        String result = "";        StringBuilder sb = new StringBuilder();        for (int i = 0; i < length; i++) {            String titleByValue = "";            if (i * 2 + 2 > comType.length()) {                sb.append(comType.substring(i * 2, length));                break;            }            String substring = comType.substring(i * 2, i * 2 + 2);            if (isNumeric(substring.trim())) {                if (Integer.valueOf(substring.trim()) == 0) {                    titleByValue = substring;                } else if (isOneNumericg(substring.trim())) {                    titleByValue = toHex(Integer.valueOf(substring.trim()));                } else {                    titleByValue = Integer.parseInt(substring.trim(), 16) + "";                    System.out.println(substring + "转换数据====" + titleByValue);                }            } else {                if (isNumericg(substring.trim())) {                    titleByValue = new BigInteger(substring.trim(), 16).toString();                    //System.out.println(substring+"转换数据1===="+titleByValue);                } else {                    titleByValue = hexStr2Str(substring.trim());                }            }            sb.append(titleByValue);        }        return sb.toString();    }    public static byte[] StringToSixteen(String hex) {        if (hex.length() < 1) {            return null;        } else {            byte[] result = new byte[hex.length() / 2];            int j = 0;            for(int i = 0; i < hex.length(); i+=2) {                result[j++] = (byte)Integer.parseInt(toHex(Integer.parseInt(hex.substring(i,i+2))), 16);                //result[j++] = (byte)toHexG(Integer.parseInt(hex.substring(i,i+2)));            }            return result;        }    }    //使用String的split 方法    public static String[] convertStrToArray(String str) {        String[] strArray = null;        strArray = str.split(","); //拆分字符为"," ,然后把结果交给数组strArray        return strArray;    }    //获取板卡信息数据类    public static Way getUsbToLists(String comType,String Code) {        String[] strArray = convertStrToArray(StringUtils.strip(comType, "[]"));        List<Card> list = new ArrayList<Card>();        Way way = new Way();        if (strArray.length ==1) {            if(Code.equals("01")) {                way.setWayCode(strArray[0]);            }            if(Code.equals("02")) {                way.setWayState(strArray[0]);            }            if(Code.equals("05")) {                way.setWayState(strArray[0]);            }            if(Code.equals("06")) {                way.setWayState(strArray[0]);            }        }        if (strArray.length > 1) {            way.setCardCode(strArray[0]);            for (int i = 1; i <= 25; i++) {                Card card = new Card();                card.setTag(i + "");                card.setMarkId(strArray[i].substring(0, 2));                card.setMarkState(strArray[i].substring(strArray[i].length() - 2, strArray[i].length()));                card.setMark(strArray[i].substring(2, 10));                list.add(card);            }            way.setCars(list);        }        return way;    }    //判断包含的六进制字符传入十进制    private static boolean isNumericg(String cadena) {        // Pattern.matches("^0[A-F]{2}",cadena);        if (Pattern.matches("^(0)[A-F]+$", cadena)) {            return true;        } else {            return false;        }    }    //判断0-9的六进制字符传入十进制    private static boolean isOneNumericg(String cadena) {        // Pattern.matches("^0[A-F]{2}",cadena);        if (Pattern.matches("^(0)[0-9]+$", cadena)) {            return true;        } else {            return false;        }    }    public static String hexStr2Str(String hexStr) {        String str = "0123456789ABCDEF";        char[] hexs = hexStr.toCharArray();        byte[] bytes = new byte[hexStr.length() / 2];        int n;        for (int i = 0; i < bytes.length; i++) {            n = str.indexOf(hexs[2 * i]) * 16;            n += str.indexOf(hexs[2 * i + 1]);            bytes[i] = (byte) (n & 0xff);        }        return new String(bytes);    }    public static void showMyToast(final Toast toast, final int cnt) {        final Timer timer = new Timer();        timer.schedule(new TimerTask() {            @Override            public void run() {                toast.show();            }        }, 0, 3500);        new Timer().schedule(new TimerTask() {            @Override            public void run() {                toast.cancel();                timer.cancel();            }        }, cnt );    }    /**     * 该方法主要使用正则表达式来判断字符串中是否包含字母     * @author fenggaopan 2015年7月21日 上午9:49:40     * @param cardNum 待检验的原始卡号     * @return 返回是否包含     */    public static boolean judgeContainsStr(String cardNum) {        String regex=".*[a-zA-Z]+.*";        Matcher m=Pattern.compile(regex).matcher(cardNum);        return m.matches();    }}